



<!doctype html>
<html>
  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Floyd–Steinberg dithering online</title>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.22.1/full/pyodide.js"></script>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
    <link rel="stylesheet" href="style.css">
  </head>

  <body>

    <textarea id="output" class="console" disabled></textarea>

    <div class="container">
      <div class="row">

        <div class="col left-side">
          <div class="title-container">
            <span class="title-name">Floyd–Steinberg dithering online</span> <br>
            made by <a href="https://github.com/rynkuns">rynkuns <span class="bi bi-github"></span></a>
          </div>
          <div class="site-desc">
            <p>Dithering is a process of minimizing quantization error,
              eg. a difference between pixels values from original range (top image) and their values from a limited range (middle image),
              by using calculated noise. Thanks to this process, when using only limited amout of values it is possible to retain details and large-scale patterns.
              Although the middle and bottom images will use the same amout of distinc colours, their percieved fidelity is much different.
            </p>
          </div>
          <div>
            <div class="parameters">
              <input type="file" onchange="readImageFile(this);" id="file">
            </div>
            <div class="parameters">
              <label for="range-max-side">Maximum resized image side lenght</label><br>
              <span id="valueMaxSide" class="slider-value">300</span>
              <input type="range" min="100" max="1000" value="300" id="range-max-side" step="25" class="slider" oninput="valueMaxSide.innerText = this.value"><br>  
              <i class="bi bi-exclamation-triangle"></i> <span style="font-size: 75%;">
                Bigger image size may result in long processing time. Please be patient in case the page freezes.
              </span>
            </div>
            <div class="parameters">
              <label for="range-n-clusters">No. of colours to split image into</label><br>
              <span id="valueNClusters" class="slider-value">5</span>
              <input type="range" min="2" max="20" value="5" id="range-n-clusters" step="1" class="slider" oninput="valueNClusters.innerText = this.value">
            </div>
            <div class="parameters">
              <label for="range-n-init">No. of times the image will be clustered<br>
                <i class="bi bi-exclamation-triangle"></i> <span style="font-size: 75%;">
                  Higher values may bring better results but with increase of processing time.
                </span></label><br>
              <span id="valueNInit" class="slider-value">1</span>
              <input type="range" min="1" max="7" value="1" id="range-n-init" step="1" class="slider" oninput="valueNInit.innerText = this.value">
            </div>
            <div class="parameters">
              <button onclick="startDithering()">start</button>
            </div>
          </div>
          <div>
            <br>Please note that this is a static site and all calculations happen on your device.<br>None of your data is stored by the author.
          </div>
        </div>

        <div class="col-md">
          <div id="image-one" class="image-container">
            <div class="image-label">the original image</div>
            <img id="uploaded_image" src="empty.png"/>
          </div>
          <div id="image-two" class="image-container">
            <div class="image-label">without dithering</div>
            <img id="mid_image" src="empty.png"/>
          </div>
          <div id="image-three" class="image-container">
            <div class="image-label">with dithering</div>
            <img id="final_image" src="empty.png"/>
          </div>
        </div>

      </div>
    </div>












    <footer class="footer">
      <div class="container">
          <div class="row">
            <div class="col"><a href="https://rynkuns.github.io"><span class="homepage">Szymon_Rynkun</span></a></div> 
            <div class="col"><span class="bi bi-slash"></span></div> 
            <div class="col"><a href="mailto:szymon.rynkun+homepage@gmail.com"><span class="bi bi-envelope"></span></a></div>
            <div class="col"><a href="https://www.linkedin.com/in/szymon-rynkun/"><span class="bi bi-linkedin"></span></a></div>
            <div class="col"><a href="https://github.com/rynkuns"><span class="bi bi-github"></span></a></div>
          </div> <!-- Bootstrap icons -->
      </div>
  </footer>




    <!-- SCRIPTS -->

    <script>
      const output = document.getElementById("output");



      function addToOutput(s) {
        output.value += s + "\n";
      }




      output.value = "Initializing Python...\n";
      async function main() {
        let pyodide = await loadPyodide();

        addToOutput("Loading packages...")
        await pyodide.loadPackage("pillow")
        await pyodide.loadPackage("numpy")
        await pyodide.loadPackage("scikit-learn")

        pyodide.runPython(`
          from PIL import Image
          import numpy as np
          from sklearn.cluster import KMeans

          from io import BytesIO
          import base64
        `)
        addToOutput("All complete. Ready!")
        return pyodide;
      }
      let pyodideReadyPromise = main();





      var image_file = null;
      async function readImageFile(input) {
        let pyodide = await pyodideReadyPromise; 

        let file = input.files[0]; 
        let fileReader = new FileReader(); 
        fileReader.readAsBinaryString(file);
        // readAsArrayBuffer

        fileReader.onload = function() {
          image_file = fileReader.result;
          let image_dims = pyodide.runPython(`
            from js import image_file
            obraz = Image.open(BytesIO(bytes(ord(c) for c in image_file))).convert("RGB") ### key moment here
            obraz.size
          `) 
          addToOutput("Image " + image_dims + " loaded.");


          max_side_value = document.getElementById("range-max-side").value
          let resized_image_dims = pyodide.runPython(`
            from js import max_side_value
            max_side_value = int(max_side_value)

            #image_dims = obraz.size
            #bigger_image_side = max(image_dims)
            #if bigger_image_side > max_side_value:
            #    bigger_index = image_dims.index(bigger_image_side)
            #    scale = max_side_value / bigger_image_side
            #    new_dims = [1,1]
            #    new_dims[bigger_index] = max_side_value
            #    new_dims[bigger_index-1] = int(image_dims[bigger_index-1] * scale)
            #    new_dims = tuple(new_dims)
            #    obraz.resize(new_dims)
            #obraz.size

            max_size = (max_side_value, max_side_value)
            obraz.thumbnail(max_size)
            obraz.size

          `) 
          addToOutput("Image resized to " + resized_image_dims)
          // addToOutput(pyodide.globals)

          uploaded_img_str = pyodide.runPython(`
            image_buf = BytesIO()
            obraz.save(image_buf, format='png')
            image_buf.seek(0)
            uploaded_img_str = 'data:image/png;base64,' + base64.b64encode(image_buf.read()).decode('UTF-8')
            uploaded_img_str
          `);
          document.getElementById("uploaded_image").src=uploaded_img_str

        }; 
        fileReader.onerror = function() {
          alert(fileReader.error);
        }; 
      }


      

      async function startDithering() {
        let pyodide = await pyodideReadyPromise;

        addToOutput("Clustering in progress...");

        n_init_value = document.getElementById("range-n-init").value
        n_clusters_value = document.getElementById("range-n-clusters").value

        pyodide.runPython(`
          from js import n_init_value, n_clusters_value

          l_klast = int(n_clusters_value)
          cluster_n_init = int(n_init_value)

          pixele = []
          for y in range(obraz.size[1]):
              for x in range(obraz.size[0]):
                  pixele.append(obraz.getpixel((x,y)))        
          klastry = KMeans(n_clusters=l_klast, random_state=0, n_init=cluster_n_init).fit(pixele)

          indeks = klastry.labels_ #lista, do któego klastra należy dany pixel
          kolor = klastry.cluster_centers_.astype(int) #wybrane przezalgorytm kolory
          


          from copy import deepcopy

          obraz_mid = deepcopy(obraz)
          mapa_mid = obraz_mid.load()
          mapa = obraz.load()


          n = 0
          for y in range(obraz_mid.size[1]):
              for x in range(obraz_mid.size[0]):
                  mapa_mid[x,y] = tuple(kolor[indeks[n]])
                  n+=1
                  
        `)
        
        addToOutput("Clustering complete.");
        // https://stackoverflow.com/questions/56583696/how-to-redirect-render-pyodide-output-in-browser
        mid_img_str = pyodide.runPython(`
          mid_image_buf = BytesIO()
          obraz_mid.save(mid_image_buf, format='png')
          mid_image_buf.seek(0)
          mid_img_str = 'data:image/png;base64,' + base64.b64encode(mid_image_buf.read()).decode('UTF-8')
          mid_img_str
        `)
        document.getElementById("mid_image").src=mid_img_str



      addToOutput("Dithering in progress...");
      pyodide.runPython(`

          def korektor(pierwotny, korekta, waga):
              """Funkcja przyjmuje wartość pierwotną pixela, oraz wyliczoną wartość błędu z poprzedniego pixela,
                a następnie aplikuje ją z odpowiednią wagą i zwraca."""
              nowy = []
              for i in range(3):
                  nowy.append(int(pierwotny[i] + korekta[i]*waga))
              return tuple(nowy)
              

          #faktyczny proces cieniowa algorytmem
          for y in range(obraz.size[1]-1):
              for x in range(1,obraz.size[0]-2):
                  oryginalny = obraz.getpixel((x,y))
                  nowy = kolor[klastry.predict(np.array(oryginalny).reshape(1, -1))][0]
                  mapa[x,y] = tuple(nowy)
                  buond = np.array([oryginalny[0] - nowy[0], oryginalny[1] - nowy[1], oryginalny[2] - nowy[2]]) #błąd przybliżenia (w skali RGB)
                  mapa[x+1,y] = korektor(obraz.getpixel((x+1,y)), buond, 7/16)
                  mapa[x-1,y+1] = korektor(obraz.getpixel((x-1,y+1)), buond, 3/16)
                  mapa[x,y+1] = korektor(obraz.getpixel((x,y+1)), buond, 5/16)
                  mapa[x+1,y+1] = korektor(obraz.getpixel((x+1,y+1)), buond, 1/16)
                  #powyżej dodawanie wartości błędu do sąsiadujących pixeli (zgodnie z algorytmem)
                      

        `)

        addToOutput("Dithering complete.");
        // https://stackoverflow.com/questions/56583696/how-to-redirect-render-pyodide-output-in-browser
        final_img_str = pyodide.runPython(`
          image_buf = BytesIO()
          obraz.save(image_buf, format='png')
          image_buf.seek(0)
          final_img_str = 'data:image/png;base64,' + base64.b64encode(image_buf.read()).decode('UTF-8')
          final_img_str
        `)
        document.getElementById("final_image").src=final_img_str
      }









/*       var content = null;

      async function doit() {
        let pyodide = await pyodideReadyPromise;
        // https://github.com/pyodide/pyodide/issues/679
        var file = document.getElementById("file").files[0];
        var reader = new FileReader();
        reader.readAsBinaryString(file);
        reader.onload = evt => { 
            content = evt.target.result; 
            var output = pyodide.runPython('from js import content\ncontent');
            var l = output.length;
            var array = new Uint8Array(l);
            for (var i = 0; i < l; i++) {
                array[i] = output.charCodeAt(i);
            }
            var blob = new Blob([array], {type: 'application/octet-stream'});
            var elem = window.document.createElement('a');
            elem.href = window.URL.createObjectURL(blob);
            elem.download = 'output.pdf';
            document.body.appendChild(elem);
            elem.click();        
            document.body.removeChild(elem);
        }
    } */


    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.min.js" integrity="sha384-mQ93GR66B00ZXjt0YO5KlohRA5SY2XofN4zfuZxLkoj1gXtW8ANNCe9d5Y3eG5eD" crossorigin="anonymous"></script>

  </body>
</html>
